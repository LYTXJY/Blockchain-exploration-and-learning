// 今天是新的一周，来到启迪区块链的第四周的第一天，已经过了
// 3*5 = 15 个工作日，与大家相处了15天。

// 今天做一个GO的基础总结，很简单。时间：2020.1.6 19：06


package main
// import "fmt"

import (
	"fmt"
	"unsafe"
)

func main(){
	// 写吧，这里是主要内容
	
	/*1.
	多段注释，没用吧，导致不熟练，摸棱两可。

	你看看，果然光听不练，都真的是假把戏，多段注释中不可以再出现 多段注释符号“  /* ” 了
	否则就会产生编译的歧义问题，导致编译出错，这点跟python不一样杨，虽然个性上磨灭了一些，但是要看到取舍，
	python简单易用，但是运行慢；反而这种严格规范的语言，这种代码风格，保证了代码的清晰与严谨性，
	GO这种编译型语言比python那种解释型语言要快。

	*/

	// 2.小细节问题：句尾不用跟分号“  ， ”，系统自动给。给了不会报错。
	// 3.编译后才能运行起来，所以必须先 
		// 3.1 go build main.go            还有个改默认名字的：go build -o xjy.exe main.go,
		// build过后，.exe文件明显变大，因为它包含了go语言可以运行的其它所有文件：
		// 换句话说，这个.exe可以运行在没有GO环境的机器上

		// 说到环境这个事情上：go的环境跟python一样好弄，下载好后，记住路径，添加进环境变量，
		// 三个环境变量： GOROOT（放解压后的GO）、GOPATH（放自己的代码路径：这里还有插一下嘴：代码路径的问题
		// 我把本地存储改成了云端存储，这样两个笔记本（神州U45S1与联想X390可以保证代码进行同时保持在最新的状态。）
		// 最后最重要的：   %GOROOT%\bin :   这个设置好了才可以windows下全局调用go命令行。    ）、
		// 3.2go run main.go
	
	// 4.开始吧：首先是讲语言都会开始讲的：类型：整形、浮点、字符、字符串、
		// 4.1整型：有符号的：int、int8、int16、int32、int64
					//无符号的：uint、uint8、uint16、uint32、uint64、 
				// int,默认为有符号64位，范围是-2**63~2**63-1
				// int8,范围-2**7~2**7-1		(这里用了个技巧，alt+shit+下箭头，实现本行代码的复制)
				// int16,范围-2**15~2**15-1		（刚才又发现个好玩的功能，alt+cap+下箭头，实现本行代码的移动）
				// 
				// uint8:范围：0~255=2**8-1
				// 
				// 
				var i1 int8 = 100
				fmt.Printf("i1 = %d, i1的类型是%T, i1占用的字节数是%d \n",i1,i1,unsafe.Sizeof(i1))
				var i2 = 3222222224.13
				fmt.Printf("i2 = %f, i2的类型是%T, i2占用的字节数是%d	\n",i2,i2,unsafe.Sizeof(i2))
				// 嗯，字节数与比特数还是没弄清楚啊，一个字节等于8个比特，
				// 所以一直显示8个字节，64个比特，64位系统，没毛病啊
		// 4.2浮点型：float，都是有符号的
		// 默认是float64,范围是：-2**63~2**63-1
				var i3 float32 = 3213.44444444444444444
				fmt.Println("n4 = \n",i3)

				// 这根“弦”始终绷不紧，浮点数使用时注意精度损失的问题！
				// 这个时候 8点30心乱了，听个歌静静
			
			//4.3字符型
			var i4 byte = 'a'
			fmt.Printf("i4 = %c \n", i4)
			fmt.Printf("i4 = %d \n", i4)

			i5 := i4 + 1
			// 这里反了个大错误啊啊！！！
			/*
			一开始的写法 i5 = i4 + 1
			乍一看，没错啊，i4定义的为字符‘a’，字符本质是数字，
			字符的本质：
				输入：输入一个字符->对应字符表（就是编码表，老一辈的ASCII,新一代通用的UTF-8）->二进制
				输出：二进制->字符表->输出一个字符
			所以还暗自欢喜，没问题啊，‘a’+1
			但是这是典型的python等语言的懒惰思想，也不能说是懒惰吧，确识也好用，但是好用惯了，就忘记它的本质了
			得先定义啊，C语言得先定义啊！！！
			i5 := i4 + 1
			
			*/
			fmt.Printf("i5 = %c \n",i5)
			// fmt.Printf("i5 = %d",i5)


		// 4.3布尔类型:bool,就俩个取值，一个true一个false
				var i6 bool
				fmt.Printf("i6 = %v \n", i6)
				// 这里，格式化输出，又多了个知识点：%v（按照变量原值输出），
				// 其它格式化输出，也回忆一下，
				// %d(整型输出)、%c(单个字符输出)、%f(浮点输出)、%s(字符串输出)、%v(按照原值输出)、%T(输出变量得类型，T:type)
				// 注意区分：	''与""	两个不一样

				var i7 = 'a'
				var i8 = "xjy"
				fmt.Printf("i7 = %c\n", i7)
				fmt.Printf("i8 = %s\n", i8)
				// 刚才重命名了，declared:申明，

		// 4.4字符串
		// 这里注意一下：反引号得使用方法，反引号，不管你里面是啥，原样输出，而正常得输出会考虑转移字符等特数字符。
		var i9 = "xjy nb \t abc\n刚才换行了看见了没\n"
		var i10 = `xjy nb \t abc\n刚才换行了看见了没\n` 	
		// 反引号是ESC下面那个符号
		fmt.Printf(i9)
		fmt.Printf(i10)

		// 字符串的拼接问题：“+”不能乱放，有规定，放在句尾，不能放在下一行的开头启示位置。
		var i11 = "qwe"+"qwe"+
		"qwe"
		fmt.Println(i11)







	fmt.Println("ok")



}